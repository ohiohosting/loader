-- LocalScript ▶ StarterGui/LedgerUI

local Players           = game:GetService("Players")
local RunService        = game:GetService("RunService")
local UserInputService  = game:GetService("UserInputService")
local LocalPlayer       = Players.LocalPlayer
local Camera            = workspace.CurrentCamera
local Mouse             = LocalPlayer:GetMouse()

-- Feature states
global_feature_states = {
    SilentAim = false,
    CamLock   = false,
    Boxes     = false,
    NameESP   = false,
    HealthBar = false,
    ToolName  = false,
    Distance  = false,
    HeadDot   = false,
    Snaplines = false,
    Chams     = false,
    OOFArrows = false,
}

-- Default keybinds
global_keybinds = {
    SilentAim = Enum.KeyCode.E,
    CamLock   = Enum.KeyCode.R,
    Boxes     = Enum.KeyCode.T,
    NameESP   = Enum.KeyCode.Y,
    HealthBar = Enum.KeyCode.U,
    ToolName  = Enum.KeyCode.I,
    Distance  = Enum.KeyCode.O,
    HeadDot   = Enum.KeyCode.P,
    Snaplines = Enum.KeyCode.LeftBracket,
    Chams     = Enum.KeyCode.RightBracket,
    OOFArrows = Enum.KeyCode.Backslash,
}

local waitingBind = nil

-- Utility: Closest target for silent aim
define getAimPart(char, name)
    return char:FindFirstChild(name) or char:FindFirstChild("HumanoidRootPart")
end

define getClosestTarget()
    local closest, minD = nil, 100
    for _,plr in ipairs(Players:GetPlayers()) do
        if plr~=LocalPlayer and plr.Character then
            local part = getAimPart(plr.Character,"Head")
            if part then
                local sp,on = Camera:WorldToViewportPoint(part.Position)
                if on then
                    local dist = (Vector2.new(sp.X,sp.Y)-Vector2.new(Mouse.X,Mouse.Y)).Magnitude
                    if dist < minD then minD,closest = dist,part end
                end
            end
        end
    end
    return closest
end

-- Silent Aim hook
local mt,oldIndex = getrawmetatable(game), getrawmetatable(game).__index
setreadonly(mt,false)
mt.__index = newcclosure(function(self,key)
    if global_feature_states.SilentAim and typeof(self)=="Instance" and self.ClassName=="Mouse" then
        if key=="Hit" then
            local h = getClosestTarget()
            if h then return CFrame.new(h.Position) end
        elseif key=="Target" then
            local h = getClosestTarget()
            if h then return h end
        end
    end
    return oldIndex(self,key)
end)
setreadonly(mt,true)

-- Create main UI
local gui = Instance.new("ScreenGui")
gui.Name = "LedgerUI"
gui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local container = Instance.new("Frame",gui)
container.Name = "Container"
container.AnchorPoint = Vector2.new(.5,.5)
container.Position    = UDim2.fromScale(.5,.5)
container.Size        = UDim2.new(0,600,0,420)
container.BackgroundColor3 = Color3.fromRGB(20,20,20)
container.BorderSizePixel = 0

-- Drag bar
local dragBar = Instance.new("Frame",container)
dragBar.Name = "DragBar"
dragBar.Size = UDim2.new(1,0,0,30)
dragBar.BackgroundColor3 = Color3.fromRGB(40,40,40)

local dragLabel = Instance.new("TextLabel",dragBar)
dragLabel.Text = "Ledger UI"
dragLabel.TextColor3 = Color3.fromRGB(255,255,255)
dragLabel.Font = Enum.Font.SourceSansBold
dragLabel.TextSize = 18
dragLabel.BackgroundTransparency = 1
dragLabel.Size = UDim2.new(1,0,1,0)

-- Drag logic
local dragging, dragInput, dragStart, startPos

dragBar.InputBegan:Connect(function(input)
    if input.UserInputType==Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = container.Position
        input.Changed:Connect(function()
            if input.UserInputState==Enum.UserInputState.End then dragging=false end
        end)
    end
end)

dragBar.InputChanged:Connect(function(input)
    if input.UserInputType==Enum.UserInputType.MouseMovement then dragInput=input end
end)

UserInputService.InputChanged:Connect(function(input)
    if input==dragInput and dragging then
        local delta = input.Position - dragStart
        container.Position = UDim2.new(startPos.X.Scale,
            startPos.X.Offset+delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset+delta.Y)
    end
end)

-- Tab creation helper
local tabs = {}
local function newTab(name)
    local f = Instance.new("Frame",container)
    f.Name = name.."Tab"
    f.Size = UDim2.new(1,-20,1,-80)
    f.Position = UDim2.new(0,10,0,50)
    f.BackgroundTransparency = 1
    f.Visible = false
    tabs[name] = f
    return f
end

-- Combat tab
local combat = newTab("Combat")
local function makeToggle(parent,name)
    local frm = Instance.new("Frame",parent)
    frm.Size = UDim2.new(1,0,0,28)
    local btn = Instance.new("TextButton",frm)
    btn.Size = UDim2.new(1,0,1,0)
    btn.BackgroundTransparency=1
    btn.TextXAlignment=Enum.TextXAlignment.Left
    btn.Font=Enum.Font.SourceSans
    btn.TextSize=16
    local state = global_feature_states[name]
    btn.Text = (state and "☑" or "☐").."   "..name
    btn.MouseButton1Click:Connect(function()
        state = not state
        global_feature_states[name]=state
        btn.Text = (state and "☑" or "☐").."   "..name
    end)
    return btn
end

makeToggle(combat,"SilentAim")
makeToggle(combat,"CamLock")
combat.UIListLayout = Instance.new("UIListLayout",combat)
combat.UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
combat.UIListLayout.Padding   = UDim.new(0,8)

-- Visuals tab
local visuals = newTab("Visuals")
for _,v in ipairs({"Boxes","NameESP","HealthBar","ToolName","Distance","HeadDot","Snaplines","Chams","OOFArrows"}) do
    makeToggle(visuals,v)
end
visuals.UIListLayout = Instance.new("UIListLayout",visuals)
visuals.UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
visuals.UIListLayout.Padding   = UDim.new(0,8)

-- Lua tab
local luaTab = newTab("Lua")
local codeBox = Instance.new("TextBox",luaTab)
codeBox.MultiLine = true; codeBox.ClearTextOnFocus=false
codeBox.Font = Enum.Font.Code; codeBox.TextSize=16
codeBox.Size = UDim2.new(1,-20,1,-60); codeBox.Position=UDim2.new(0,10,0,10)

local function makeBtn(txt,x,cb)
    local b=Instance.new("TextButton",luaTab)
    b.Text=txt; b.Font=Enum.Font.SourceSans; b.TextSize=16
    b.Size=UDim2.new(0,100,0,30)
    b.Position=UDim2.new(0,10+x*110,1,-40)
    b.BackgroundColor3=Color3.fromRGB(40,40,40); b.BorderSizePixel=0
    b.MouseButton1Click:Connect(cb)
    return b
end
makeBtn("Execute",0,function()
    local ok,err = pcall(function()
        local fn = assert(loadstring(codeBox.Text),"compile error")
        fn()
    end)
    if not ok then warn(err) end
end)
makeBtn("Clear",1,function() codeBox.Text="" end)

-- Settings tab (keybinds)
local settings = newTab("Settings")
local yOff=0
for feat,_ in pairs(global_feature_states) do
    local frm=Instance.new("Frame",settings)
    frm.Size=UDim2.new(1,0,0,28); frm.Position=UDim2.new(0,0,0,yOff)
    local lbl=Instance.new("TextLabel",frm)
    lbl.Text=feat; lbl.Font=Enum.Font.SourceSans; lbl.TextSize=16
    lbl.TextXAlignment=Enum.TextXAlignment.Left
    lbl.BackgroundTransparency=1; lbl.Size=UDim2.new(.5,0,1,0)
    local btn=Instance.new("TextButton",frm)
    btn.Text=global_keybinds[feat].Name; btn.Font=Enum.Font.SourceSans; btn.TextSize=16
    btn.Size=UDim2.new(.5,-10,1,0); btn.Position=UDim2.new(.5,10,0,0)
    btn.MouseButton1Click:Connect(function()
        waitingBind=feat; btn.Text="Press key..."
    end)
    yOff=yOff+32
end

-- Tab bar
local tabBar=Instance.new("Frame",container)
tabBar.Size=UDim2.new(1,0,0,30); tabBar.Position=UDim2.new(0,0,1,-30)
for i,name in ipairs({"Combat","Visuals","World","Lua","Settings"}) do
    local b=Instance.new("TextButton",tabBar)
    b.Text=name:sub(1,1)
    b.Font=Enum.Font.Code; b.TextSize=20
    b.Size=UDim2.new(0,120,1,0)
    b.Position=UDim2.new(0,(i-1)*120,0,0)
    b.BackgroundColor3=Color3.fromRGB(40,40,40); b.BorderSizePixel=0
    b.MouseButton1Click:Connect(function()
        for _,f in pairs(tabs) do f.Visible=false end
        tabs[name].Visible=true
    end)
end
-- default tab
tabs["Combat"].Visible=true

-- Input handling for keybinds
UserInputService.InputBegan:Connect(function(input,processed)
    if not processed then
        if waitingBind and input.UserInputType==Enum.UserInputType.Keyboard then
            global_keybinds[waitingBind]=input.KeyCode
            -- update button text
            local frm=settings:FindFirstChild(waitingBind.."Keyframe")
            -- simplified: skip updating label here
            waitingBind=nil
        else
            for feat,key in pairs(global_keybinds) do
                if input.KeyCode==key then
                    global_feature_states[feat]=not global_feature_states[feat]
                end
            end
        end
    end
end)
